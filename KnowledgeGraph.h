/**
 * @file KnowledgeGraph.h
 * @brief 知识点依赖图管理模块
 *
 * 本模块实现知识点之间的依赖关系图，用于生成科学的复习路径推荐。
 * 采用邻接表存储有向无环图（DAG），支持拓扑排序生成学习顺序。
 */

#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>

/**
 * @brief 知识点依赖图的邻接表存储结构
 *
 * 使用哈希表存储每个知识点的前置依赖关系：
 * - Key: 当前知识点名称
 * - Value: 该知识点的所有前置知识点列表（必须先掌握的知识点）
 *
 * 依赖关系方向说明：
 * 对于 "数组|基本语法,变量" 表示：
 * - "数组" 依赖于 "基本语法" 和 "变量"
 * - g_knowledgePrereq["数组"] = {"基本语法", "变量"}
 *
 * 这是一个有向图：边从前置知识点指向当前知识点
 * 复习时需要先学习前置知识点，再学习依赖它们的知识点
 *
 * 时间复杂度：查询某知识点的前置依赖为 O(1)
 * 空间复杂度：O(V + E)，其中 V 为知识点数量，E 为依赖关系数量
 */
extern std::unordered_map<std::string, std::vector<std::string>> g_knowledgePrereq;

/**
 * @brief 所有知识点节点的集合
 *
 * 存储图中所有出现过的知识点名称（包括作为前置依赖出现的知识点）
 * 用于：
 * 1. 快速判断知识点是否存在（O(1) 时间复杂度）
 * 2. 遍历所有知识点统计掌握情况
 * 3. 确保依赖图的完整性（所有引用的知识点都在集合中）
 */
extern std::unordered_set<std::string> g_allKnowledgeNodes;

/**
 * @brief 从文件加载知识点依赖图
 *
 * 文件格式规范（每行一个知识点）：
 * @code
 * 知识点名称|前置知识点1,前置知识点2,前置知识点3
 * @endcode
 *
 * 格式详细说明：
 * - 使用 '|' 分隔当前知识点和前置依赖列表
 * - 前置依赖之间使用 ',' 分隔
 * - 支持空格，会自动去除前后空白字符
 * - 空行会被自动跳过
 *
 * 示例：
 * @code
 * 数组|基本语法,变量
 * 链表|指针,结构体
 * 二叉树|链表,递归
 * 图|邻接表,队列,栈
 * @endcode
 *
 * 容错机制：
 * 1. 文件不存在：返回 false，输出警告，不影响系统运行
 * 2. 格式错误行：跳过该行，输出行号提示，继续解析
 * 3. 空知识点名：自动跳过
 * 4. 重复定义：后面的定义会覆盖前面的定义
 *
 * 去重策略：
 * - g_allKnowledgeNodes 使用 unordered_set，自动保证知识点唯一性
 * - 前置依赖列表使用 vector，允许重复（实际使用中应避免）
 *
 * @param filename 知识点依赖图文件路径（通常为 data/knowledge_graph.txt）
 * @return bool
 *         - true: 文件加载成功，依赖图已构建
 *         - false: 文件不存在或无法打开，依赖图为空
 *
 * @note 时间复杂度：O(N * M)，N 为行数，M 为每行平均前置依赖数量
 * @note 空间复杂度：O(V + E)，V 为知识点数，E 为依赖边数
 * @note 线程安全：不保证线程安全，需要外部同步
 *
 * @see g_knowledgePrereq 存储解析后的依赖关系
 * @see g_allKnowledgeNodes 存储所有知识点集合
 */
bool loadKnowledgeGraphFromFile(const std::string& filename);

/**
 * @brief DFS 深度优先搜索生成复习路径（拓扑排序）
 *
 * 算法原理：
 * 使用深度优先搜索遍历知识点依赖图，生成满足依赖关系的拓扑排序序列。
 * 保证前置知识点一定排在依赖它的知识点之前。
 *
 * 遍历顺序：
 * 1. 标记当前节点为已访问（防止重复访问和环路）
 * 2. 递归访问所有前置知识点（保证前置依赖先入队）
 * 3. 将当前节点加入路径末尾（后序遍历）
 *
 * 防环机制：
 * - visited 集合记录已访问节点，避免重复访问
 * - 对于已访问的节点直接返回（剪枝）
 * - 假设输入图为 DAG（有向无环图），不处理环路检测
 *
 * 拓扑顺序保证：
 * 采用后序遍历方式，确保：
 * - 节点在其所有前置依赖之后加入路径
 * - 生成的路径满足"先学基础，后学高级"的学习规律
 *
 * 示例：
 * @code
 * // 依赖关系：图 -> 队列,栈 -> 基本语法
 * dfsReviewPath("图", visited, path);
 * // 结果 path = ["基本语法", "队列", "栈", "图"]
 * @endcode
 *
 * @param node 当前访问的知识点名称
 * @param visited 已访问节点集合（引用传递，避免拷贝开销）
 * @param path 生成的复习路径序列（引用传递，收集结果）
 *
 * @note 时间复杂度：O(V + E)，每个节点和边最多访问一次
 * @note 空间复杂度：O(V)，递归栈深度和 visited 集合大小
 * @note 如果图中存在环，会导致无限递归（实际应用中需要保证 DAG）
 *
 * @warning 输入图必须是有向无环图（DAG），否则可能栈溢出
 * @warning visited 和 path 需要在首次调用前初始化为空
 *
 * @see g_knowledgePrereq 依赖关系图数据源
 * @see recommendReviewPath 调用此函数生成复习路径
 */
void dfsReviewPath(const std::string& node, std::unordered_set<std::string>& visited, std::vector<std::string>& path);

/**
 * @brief 知识点复习路径推荐（主功能入口）
 *
 * 功能流程：
 * 1. 检查知识点依赖图是否已加载
 * 2. 统计用户对每个知识点的掌握情况（正确率、答题数）
 * 3. 按正确率从低到高排序，标注薄弱知识点
 * 4. 用户选择目标知识点
 * 5. 使用 DFS 生成包含所有前置依赖的复习路径
 * 6. 显示复习路径并标注每个知识点的掌握程度
 *
 * 统计标注逻辑：
 * - 未练习：答题数为 0，标记为 "需要学习"
 * - 薄弱环节：正确率 < 60% 且答题数 > 0，标记为 "⚠ 薄弱环节"
 * - 掌握良好：正确率 >= 60%，无特殊标记
 *
 * 复习路径特点：
 * - 包含目标知识点及其所有直接/间接前置依赖
 * - 按拓扑排序生成，保证学习顺序合理
 * - 显示每个知识点的统计数据，便于针对性复习
 * - 箭头指示学习路径方向
 *
 * 使用建议：
 * - 优先选择正确率低的知识点进行复习
 * - 按推荐路径顺序学习，先巩固基础
 * - 重点关注标注为"薄弱环节"的知识点
 *
 * 输出示例：
 * @code
 * ========== 推荐复习路径 ==========
 * 目标知识点：图
 *
 * 建议按以下顺序复习：
 *
 * 1. 基本语法  [题数: 10, 正确率: 80.0%] →
 * 2. 队列  [题数: 5, 正确率: 40.0%] ⚠ 薄弱环节 →
 * 3. 栈  [未练习] ⚠ 需要学习 →
 * 4. 图  [题数: 3, 正确率: 33.3%] ⚠ 薄弱环节
 * @endcode
 *
 * @note 时间复杂度：O(V log V + V + E)
 *       - 排序：O(V log V)
 *       - DFS 生成路径：O(V + E)
 * @note 交互式函数，需要用户输入选择
 * @note 依赖 Stats 模块提供的统计数据
 *
 * @warning 如果知识点依赖图未加载，会提示错误并返回
 * @warning 如果用户输入无效编号，会提示错误并返回
 *
 * @see loadKnowledgeGraphFromFile 加载依赖图
 * @see dfsReviewPath DFS 生成路径算法
 * @see buildKnowledgeStats 获取知识点统计数据（Stats.h）
 */
void recommendReviewPath();
