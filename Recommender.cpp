/**
 * @file Recommender.cpp
 * @brief AI 智能推荐系统实现文件
 *
 * 实现多维度加权评分算法，基于用户历史数据智能推荐最适合练习的题目。
 */

#include "Recommender.h"
#include "Record.h"
#include "Utils.h"
#include <iostream>
#include <queue>
#include <ctime>
#include <cmath>

/**
 * @brief 计算题目的推荐评分（实现）
 *
 * 多维度加权评分算法的核心实现，综合考虑以下四个维度：
 *
 * **【维度 1：错误率 - 权重 0.6】**
 * - 目的：识别用户的薄弱知识点
 * - 计算方式：errorRate = (总尝试次数 - 正确次数) / 总尝试次数
 * - 特殊处理：
 *   * 若用户从未做过该题，则 errorRate = 1.0（最高值）
 *   * 确保新题目有机会被推荐
 * - 意义：错误率越高 → 该题是弱项 → 越需要练习
 *
 * **【维度 2：时间间隔 - 权重 0.3】**
 * - 目的：实现基于遗忘曲线的智能复习
 * - 计算方式：
 *   1. 计算距上次做题的天数：timeGapDays = (now - lastTimestamp) / 86400
 *   2. 归一化到 [0, 1]：timeScore = min(timeGapDays / 7.0, 1.0)
 * - 特殊处理：
 *   * 若从未做过，则给予 timeGapDays = 7.0（一周间隔）
 *   * 超过 7 天的按满分 1.0 计算
 * - 意义：间隔越久 → 遗忘风险越高 → 越需要复习
 *
 * **【维度 3：难度 - 权重 0.1】**
 * - 目的：适当倾斜推荐难题，促进能力提升
 * - 计算方式：diffScore = 0.2 + (difficulty - 1) × 0.2
 * - 映射关系：难度 [1, 2, 3, 4, 5] → 分数 [0.2, 0.4, 0.6, 0.8, 1.0]
 * - 意义：难度越高 → 越有挑战性 → 适当提高推荐优先级
 *
 * **【维度 4：未做奖励 - 固定加分 +0.2】**
 * - 目的：鼓励探索新题目，避免题库覆盖不全
 * - 计算方式：unseenBonus = (totalAttempts == 0 ? 0.2 : 0.0)
 * - 意义：未做题目直接加 0.2 分，增加曝光机会
 *
 * **【综合评分公式】**
 * @code
 * score = 0.6 × errorRate      // 错误率（主导因素）
 *       + 0.3 × timeScore      // 时间间隔（复习提醒）
 *       + 0.1 × diffScore      // 难度（梯度提升）
 *       + unseenBonus          // 未做奖励（探索鼓励）
 * @endcode
 *
 * **【权重设计理念】**
 * - 错误率 0.6：主导因素，确保用户优先攻克薄弱点
 * - 时间间隔 0.3：次要因素，防止遗忘，强化长期记忆
 * - 难度 0.1：调节因素，适度提升挑战性
 * - 未做奖励 0.2：探索激励，保证题库全覆盖
 *
 * **【权重可调性建议】**
 * 根据不同学习目标，可灵活调整权重配置：
 *
 * | 学习目标     | 错误率 | 时间间隔 | 难度 | 说明                     |
 * |-------------|--------|----------|------|--------------------------|
 * | 补弱项模式   | 0.7    | 0.2      | 0.1  | 强化错题练习             |
 * | 复习模式     | 0.4    | 0.5      | 0.1  | 注重遗忘曲线复习         |
 * | 挑战模式     | 0.3    | 0.2      | 0.5  | 攻克高难度题目           |
 * | 平衡模式     | 0.6    | 0.3      | 0.1  | 当前配置，均衡发展       |
 *
 * @param q 题目对象，提供静态属性（难度、类型等）
 * @param st 题目统计信息，提供动态数据（做题次数、正确率、时间戳等）
 * @param now 当前时间戳（Unix timestamp，单位：秒）
 *
 * @return 推荐评分，范围 [0.0, 2.0]
 *         - 0.0 ~ 0.5：低优先级（已掌握的简单题目）
 *         - 0.5 ~ 1.2：中等优先级（需要适当练习）
 *         - 1.2 ~ 2.0：高优先级（薄弱点或长期未练习）
 *
 * @note 时间复杂度：O(1)，所有计算都是常数时间操作
 * @note 空间复杂度：O(1)，仅使用局部变量
 */
double computeRecommendScore(const Question& q, const QuestionStat& st, long long now) {
    // ============================================================
    // 维度 1：错误率计算（权重 0.6）
    // ============================================================
    double errorRate = 1.0; // 初始化为最高值（假设未做过）
    if (st.totalAttempts > 0) {
        // 已做过的题：计算实际错误率
        // errorRate = 错误次数 / 总次数
        errorRate = (st.totalAttempts - st.correctAttempts) * 1.0 / st.totalAttempts;
    }
    // 未做过的题：保持 errorRate = 1.0，确保新题有较高优先级

    // ============================================================
    // 维度 2：时间间隔计算（权重 0.3）
    // ============================================================
    double timeGapDays = 1.0; // 默认 1 天（避免除零）
    if (st.lastTimestamp > 0) {
        // 有做题记录：计算距今天数
        double seconds = difftime(now, (time_t)st.lastTimestamp);
        if (seconds < 0) seconds = 0; // 防止时间戳异常（未来时间）
        timeGapDays = seconds / 86400.0; // 转换为天数（86400 秒/天）
    } else {
        // 从未做过：给予 7 天的默认间隔，表示"该复习了"
        timeGapDays = 7.0;
    }

    // 归一化到 [0, 1]：以 7 天为基准，超过 7 天按满分计算
    // 设计理念：7 天是记忆衰减的关键节点（艾宾浩斯遗忘曲线）
    double timeScore = timeGapDays / 7.0;
    if (timeScore > 1.0) timeScore = 1.0; // 上限截断

    // ============================================================
    // 维度 3：难度权重计算（权重 0.1）
    // ============================================================
    // 难度范围 [1, 5] 线性映射到 [0.2, 1.0]
    // 公式：diffScore = 0.2 + (difficulty - 1) × 0.2
    // 映射表：1→0.2, 2→0.4, 3→0.6, 4→0.8, 5→1.0
    double diffScore = 0.2 + (q.difficulty - 1) * 0.2;

    // 边界保护：防止异常难度值导致越界
    if (diffScore < 0.2) diffScore = 0.2; // 最低 0.2（难度1）
    if (diffScore > 1.0) diffScore = 1.0; // 最高 1.0（难度5+）

    // ============================================================
    // 维度 4：未做奖励（固定加分 +0.2）
    // ============================================================
    // 若从未尝试过该题，给予额外奖励，鼓励探索未知领域
    double unseenBonus = (st.totalAttempts == 0 ? 0.2 : 0.0);

    // ============================================================
    // 综合评分：加权求和
    // ============================================================
    // 权重分配：
    // - 0.6：错误率（主导）→ 攻克薄弱点
    // - 0.3：时间间隔（辅助）→ 防止遗忘
    // - 0.1：难度（调节）→ 梯度提升
    // - +0.2：未做奖励（激励）→ 题库覆盖
    double score = 0.6 * errorRate + 0.3 * timeScore + 0.1 * diffScore + unseenBonus;

    // ============================================================
    // 边界保护：限制评分范围
    // ============================================================
    // 理论最大值：0.6×1 + 0.3×1 + 0.1×1 + 0.2 = 1.2
    // 但为防止异常，设置上限 2.0，下限 0.0
    if (score < 0.0) score = 0.0;
    if (score > 2.0) score = 2.0;

    return score;
}

/**
 * @brief AI 智能推荐模式主函数（实现）
 *
 * 基于用户历史做题数据，运用多维度评分算法智能推荐最适合练习的 Top-K 题目。
 *
 * **【算法流程详解】**
 *
 * **Step 1：前置检查**
 * - 检查题库是否为空，空题库无法推荐
 * - 若为空，提示用户并返回
 *
 * **Step 2：更新统计信息**
 * - 调用 buildQuestionStats() 重新统计所有题目的做题记录
 * - 确保统计数据是最新的（用户可能刚做完题）
 * - 统计内容包括：每道题的总尝试次数、正确次数、最后做题时间戳
 *
 * **Step 3：获取当前时间**
 * - 记录当前时间戳 now = time(nullptr)
 * - 用于计算距上次做题的时间间隔
 *
 * **Step 4：评分阶段（核心步骤）**
 * - 遍历所有题目，时间复杂度 O(N)，其中 N = 题库总数
 * - 对每道题：
 *   1. 从 g_questionStats 中查找该题的统计信息（O(log N)，map 查找）
 *   2. 若无统计信息，使用默认值（表示从未做过）
 *   3. 调用 computeRecommendScore() 计算推荐分数（O(1)）
 *   4. 将 {题目ID, 分数} 封装成 RecommendItem 插入优先队列（O(log N)）
 *
 * **Step 5：使用优先队列（大顶堆）维护 Top-K**
 * - 为什么用 priority_queue：
 *   * 自动维护堆序性质，堆顶始终是分数最高的题目
 *   * 插入操作 O(log N)，取堆顶 O(1)
 *   * 无需手动排序，空间效率高
 *   * STL 实现高效稳定
 * - 为什么是大顶堆：
 *   * 需要推荐分数最高的 K 道题
 *   * 大顶堆堆顶即为最大值，符合需求
 *   * 通过重载 operator< 实现（score 小的返回 true）
 *
 * **Step 6：提取 Top-K 题目**
 * - 从优先队列中依次取出前 K 个题目（O(K log N)）
 * - 若题库总数 < K，则推荐全部题目
 * - 存储到 selected 向量中，保持推荐顺序（分数从高到低）
 *
 * **Step 7：展示推荐列表并进入练习**
 * - 打印推荐说明，告知用户推荐依据（错误率、时间间隔、难度）
 * - 逐题展示并调用 doQuestion() 让用户作答
 * - doQuestion() 内部会：
 *   * 显示题目内容和选项
 *   * 接收用户答案
 *   * 判断正误并记录到 records.txt
 *   * 实时更新统计信息
 *
 * **Step 8：结束与清理**
 * - 打印结束提示
 * - 调用 pauseForUser() 暂停等待用户确认
 * - 返回主菜单
 *
 * **【时间复杂度分析】**
 *
 * 设题库总数为 N，推荐数量为 K（通常 K = 5 << N）：
 *
 * 1. 统计更新：O(M log N)，M = 做题记录数，N = 题目数（map 插入）
 * 2. 遍历题目：O(N)
 * 3. 查找统计：O(log N) × N = O(N log N)（map 查找）
 * 4. 计算评分：O(1) × N = O(N)
 * 5. 插入堆：O(log N) × N = O(N log N)（优先队列插入）
 * 6. 取出 Top-K：O(log N) × K = O(K log N)
 * 7. 做题过程：O(K)（用户交互，与算法复杂度无关）
 *
 * **总体时间复杂度：O(N log N)**
 * - 主要瓶颈在于 map 查找和优先队列插入
 * - 对于小规模题库（N < 10000），性能表现优秀
 * - 可进一步优化为 O(N log K)（使用小顶堆维护 Top-K）
 *
 * **【空间复杂度分析】**
 *
 * 1. 优先队列：O(N)，存储所有题目的推荐项
 * 2. selected 向量：O(K)
 * 3. 统计信息 map：O(N)
 * 4. 局部变量：O(1)
 *
 * **总体空间复杂度：O(N)**
 *
 * **【优化建议】**
 *
 * 若题库规模较大（N > 100000），可采用以下优化：
 *
 * 1. **小顶堆优化（O(N log K)）**
 *    - 维护大小为 K 的小顶堆
 *    - 遇到更大分数时替换堆顶
 *    - 时间复杂度降为 O(N log K)
 *
 * 2. **缓存评分结果**
 *    - 若统计信息未变，无需重复计算
 *    - 可使用 memoization 技术
 *
 * 3. **并行计算**
 *    - 评分计算可并行化（各题目独立）
 *    - 使用 OpenMP 或线程池
 *
 * @note 当前配置：K = 5，可根据需求调整
 * @note 若用户中途退出做题，已做题目的记录会保存
 *
 * @see computeRecommendScore() 评分算法详解
 * @see RecommendItem 推荐项数据结构
 * @see buildQuestionStats() 统计信息构建
 * @see doQuestion() 题目作答流程
 */
void aiRecommendMode() {
    // ============================================================
    // Step 1：前置检查 - 题库是否为空
    // ============================================================
    if (g_questions.empty()) {
        std::cout << "题库为空，无法推荐。\n";
        pauseForUser();
        return;
    }

    // ============================================================
    // Step 2：更新统计信息 - 确保数据是最新的
    // ============================================================
    // 重要：用户可能刚做完题，需要重新统计才能获取最新的错误率和时间戳
    // buildQuestionStats() 会遍历 records.txt，重建 g_questionStats
    buildQuestionStats();

    // ============================================================
    // Step 3：获取当前时间戳
    // ============================================================
    // 用于计算距上次做题的时间间隔（维度 2）
    long long now = (long long)std::time(nullptr);

    // ============================================================
    // Step 4 & 5：评分 + 堆维护 - 核心算法
    // ============================================================
    // 使用优先队列（大顶堆）自动维护分数最高的题目
    // 优点：
    // 1. 自动排序，无需手动 sort()
    // 2. 插入效率 O(log N)，优于排序的 O(N log N)
    // 3. 取堆顶 O(1)，快速获取最高分
    // 4. STL 实现稳定高效
    std::priority_queue<RecommendItem> pq;

    // 遍历所有题目，计算推荐分数并插入堆
    // 时间复杂度：O(N log N)
    for (const auto& q : g_questions) {
        QuestionStat st; // 默认初始化（totalAttempts = 0, lastTimestamp = 0）

        // 从统计 map 中查找该题的记录
        auto it = g_questionStats.find(q.id);
        if (it != g_questionStats.end()) {
            st = it->second; // 找到记录，使用实际统计数据
        }
        // 未找到记录：使用默认值（视为从未做过）

        // 计算推荐评分（O(1)）
        double s = computeRecommendScore(q, st, now);

        // 插入优先队列（O(log N)）
        pq.push({q.id, s});
    }

    // ============================================================
    // Step 6：确定推荐数量 K
    // ============================================================
    int K = 5; // 默认推荐 5 道题（可根据需求调整）
    if ((int)g_questions.size() < K) {
        K = (int)g_questions.size(); // 题库不足 K 道，推荐全部
    }

    // 打印推荐说明
    std::cout << "【AI 智能推荐模式】本次为你推荐 " << K << " 道题。\n";
    std::cout << "根据你的历史做题记录，优先推荐错误率高、长期未练习或难度较高的题目。\n\n";

    // ============================================================
    // Step 6：提取 Top-K 题目 ID
    // ============================================================
    std::vector<int> selected;
    selected.reserve(K); // 预分配空间，避免动态扩容

    // 从堆中依次取出前 K 个最高分题目
    // 时间复杂度：O(K log N)
    while (!pq.empty() && (int)selected.size() < K) {
        selected.push_back(pq.top().questionId); // 取堆顶元素
        pq.pop();                                 // 弹出堆顶
    }

    // ============================================================
    // Step 7：逐题展示并进入练习模式
    // ============================================================
    for (size_t i = 0; i < selected.size(); ++i) {
        int qid = selected[i];

        // 从全局 map 中查找题目对象指针
        auto itQ = g_questionById.find(qid);
        if (itQ == g_questionById.end()) continue; // 异常情况：题目不存在，跳过

        // 打印题目序号分隔线
        std::cout << "-----------------------------\n";
        std::cout << "第 " << (i + 1) << " 道推荐题：\n";

        // 调用做题函数（显示题目、接收答案、判断正误、记录结果）
        doQuestion(*itQ->second);

        std::cout << "\n";
    }

    // ============================================================
    // Step 8：结束提示
    // ============================================================
    std::cout << "本轮 AI 推荐练习结束。\n";

    // 暂停等待用户确认（按任意键继续）
    pauseForUser();
}
